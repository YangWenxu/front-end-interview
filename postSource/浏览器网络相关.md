---
title: 浏览器网络相关
tags: front-end
categories: interview
---

1. 浏览器：repaint，reflow，cookie,session,跨域，缓存，URL参数解析
2. 网络：http1，http2，状态码，http，https，get，post，三次握手

<!--more-->

## reflow(回流)和repaint(重绘)优化

- 浏览器渲染过程: DOM tree, CSS tree --> Render tree --> Paint

- DOM tree根节点为html

- 渲染从浏览器左上角到右下角

- 第一次打开页面至少触发一次重绘和回流, 结构如宽高位置变化时, 触发**reflow回流**;非结构如背景色变化时, 触发**repaint重绘**. 二者都会造成体验不佳

- 如何减少重绘和回流?

- - 通过classname或cssText一次性修改样式, 而非一个一个改
  - 离线模式: 克隆要操作的结点, 操作后再与原始结点交换, 类似于虚拟DOM
  - 避免频繁直接访问计算后的样式, 而是先将信息保存下来
  - 绝对布局的DOM, 不会造成大量reflow
  - p不要嵌套太深, 不要超过六层

##  一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？

- 浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；
- 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；
- 浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM Tree）；
- 载入解析到的资源文件，渲染页面，完成。

## localStorage 与 sessionStorage的区别总结

- **共同点**: 都保存在浏览器端, 且同源
- localStorage 与 sessionStorage 统称webStorage,保存在浏览器,不参与服务器通信,大小为5M
- **生命周期不同**: localStorage永久保存, sessionStorage当前会话, 都可手动清除
- **作用域不同**: 不同浏览器不共享local和session, 不同会话不共享session
- **Cookie**: 设置的过期时间前一直有效, 大小4K.有个数限制, 各浏览器不同, 一般为20个.携带在HTTP头中, 过多会有性能问题.可自己封装, 也可用原生

## cookie与session的区别总结

1.Cookie是将会话状态保存在浏览器的技术；Session是将会话状态保存在服务器的技术；

2.Cookie中的数据保存时间较长(可调)；Session中的数据保存时间较短，约为30分钟(可调)；

3.Cookie数据的安全性和稳定性较差(原因是数据保存在用户手中，用户可进行任意修改，病毒可轻易攻击)；

   Session数据的安全性和稳定性较高(服务器的安全性高，数据存在服务器上安全性高)；

4.Cookie的大小有限制，大小约为4kb。Session的大小无限制，理论上可无限大(Session是存在服务器的内存中的，当Session的大小超出内存可承受范围，就会	自动存储到服务器的硬盘中)。

5 保存数据，cookie只能保存字符串类型的数据，session可以保存任意类型的数据。

cookie对象和session对象一样是用来保存特定的用户相关的数据，用户和服务器连接时，就建立了一个session，服务器为之分配了一个唯一的sessionID。
很多时候session是和cookie共同使用的，客户端将请求和cookie发送至服务器，session根据唯一sessionID和cookie辨别用户。这样既增加了安全机制，也可以方便用户操作。

## 为什么浏览器的请求有两次，一次options，第二次才是真正请求？哪些场景用到 

##  跨域，预检请求，同源策略
##  浏览器的缓存机制

- 浏览器缓存就是把一个已经请求过的资源拷贝一份存储起来，当下次需要该资源时，浏览器会根据缓存机制决定直接使用缓存资源还是再次向服务器发送请求.
- from memory cache ; from disk cache
- 作用: 减少网络传输的损耗以及降低服务器压力。
- 优先级: 强制缓存 > 协商缓存; cache-control > Expires > Etag > Last-modified

##  http和https的区别总结

- http: 最广泛网络协议，BS模型，浏览器高效。
- https: 安全版，通过SSL加密，加密传输，身份认证，密钥

1. https相对于http加入了ssl层, 加密传输, 身份认证;
2. 需要到ca申请收费的证书;
3. 安全但是耗时多，缓存不是很好;
4. 注意兼容http和https;
5. 连接方式不同, 端口号也不同, http是80, https是443

##  http状态码

```
100  Continue  继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息
200  OK   正常返回信息
201  Created  请求成功并且服务器创建了新的资源
202  Accepted  服务器已接受请求，但尚未处理
301  Moved Permanently  请求的网页已永久移动到新位置。
302 Found  临时性重定向。
303 See Other  临时性重定向，且总是使用 GET 请求新的 URI。
304  Not Modified  自从上次请求后，请求的网页未修改过。

400 Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。
401 Unauthorized  请求未授权。
403 Forbidden  禁止访问。
404 Not Found  找不到如何与 URI 相匹配的资源。

500 Internal Server Error  最常见的服务器端错误。
503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。
```

## http,tcp,UDP

- TCP（Transmission Control Protocol：传输控制协议；面向连接，可靠传输

- UDP（User Datagram Protocol）：用户数据报协议；面向无连接，不可靠传输

1、应用层协议：HTTP、FTP、SMTP、DNS、TELNET、HTTPS等；

2、表示层不需要协议；

3、会话层不需要协议；

4、传输层协议：TCP、UDP等； 

5、网络层协议：ICMP、IGMP、IP（IPV4 IPV6）、ARP、RARP等； IP地址 32位，

6、数据链路层协议：802.11、802.16、Wi-Fi、WiMAX、ATM、DTM、GPRS、EVDO、HSPA等；MAC地址 48位

7、物理层协议：FTP、Telnet、SMTP、SNTP、REXEC、TFTP、LPD、SNMP、NFS、INETD等 。

## http2.0。http在哪一层，tcp在哪一层 

`HTTP/2`引入了“服务端推（serverpush）”的概念，它允许服务端在客户端需要数据之前就主动地将数据发送到客户端缓存中，从而提高性能。
`HTTP/2`提供更多的加密支持
`HTTP/2`使用多路技术，允许多个消息在一个连接上同时交差。它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的`header`都只会占用很小比例的带宽。

**http1.0**

无状态无连接

**http1.1**

持久连接

请求管道化

增加缓存处理(新的字段如cache-control)

增加Host字段，支持断点传输等

**http2.0**

二进制分帧

多路复用(或连接共享)

头部压缩

服务器推送

##  get请求和post请求的区别
```
    GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符
    POST：一般用于修改服务器上的资源，对所发送的信息没有限制。

    GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，
    也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。

然而，在以下情况中，请使用 POST 请求：
无法使用缓存文件（更新服务器上的文件或数据库）
向服务器发送大量数据（POST 没有数据量限制）
发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
```
## 正向代理和反向代理

**正向代理(客户端)**

（1）访问原来无法访问的资源，如google
（2） 可以做缓存，加速访问资源
（3）对客户端访问授权，上网进行认证
（4）代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息

**反向代理(服务器端)**

（1）保证内网的安全，可以使用反向代理提供WAF功能，阻止web攻击大型网站，通常将反向代理作为公网访问地址，Web服务器是内网。

（2）负载均衡，通过反向代理服务器来优化网站的负载

## 三次握手四次挥手

1. 第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；

2. 第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；

3. 第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。
   完成了三次握手，客户端和服务器端就可以开始传送数据。

第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接

四次挥手：客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文，断开连接。

## url查询参数解析 
